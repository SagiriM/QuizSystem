9f04620a-a969-459a-8cd0-300132a8504b---
26---
SingleChoice---
求整数n(n>=0)结成的算法如下，其时间复杂度是（）
int fact(int n) {
    if(n<=1) return 1;
    return n * fact(n-1);
}
A.O(log2 n) B.O(n) C.O(nlog2 n) D.O(n^2)---
B
===
32c18f91-faf2-4302-8afd-fd5574f49009---
27---
SingleChoice---
设有一个递归算法如下：
int X(int n) {
    if(n<=3) return 1;
    else return X(n-2)+X(n-2)+1;
}
计算X(X(5))时需要调用（）次X函数。
A.4 B.5 C.8 D.16---
A
===
90301a0d-dc4c-422a-9d34-c5321880a2e7---
28---
SingleChoice---
下列程序段的时间复杂度是（）。
count=1;
for(k=1;k<=n;k*=2)
    for(j=1;j<=n;j++)
        count++;
A.O(log2 n) B.O(n) C.O(nlog2 n) D.O(n^2)---
C
===
8a5619db-3488-459e-b2e2-371f1ee4e31d---
29---
SingleChoice---
下面是一个程序段：
int p=1,s=0;
for(int i=1;i<=n;i++)
    {p+=i;s+=p;}
其时间复杂度为（）。
A.O(1) B.O(n) C.O(nlog2 n) D.O(n^2)---
B
===
277ff32d-58f2-49c4-9a1e-c036d8d97148---
30---
SingleChoice---
下面是一个递归的排序算法：
void Sorting(int[] A,int left,int right) {
    if(right->left>0) {
        int mid=(right-left+1)/2;
        Sorting(A,left,mid);
        Sorting(A,mid+1,right);
        Merge(A,left,right);
    }
}
其时间复杂度为（）。
A.O(1) B.O(n) C.O(nlog2 n) D.O(n^3)---
C
===
c1ebdc6a-9267-4b60-8e10-49866eeef7c1---
31---
SingleChoice---
在以下程序段中，语句s的执行频度为（）。
for(i=1;i<n-1;i++)
    for(j=n;j>=i;j--)
        s;
A.n(n-1)/2 B.n(n+1)/2 C.(n+1)(n-1)/2 D.(n+3)(n-2)/2---
D
===
accb6ed8-5840-478a-ab9b-ef49158fa676---
32---
SingleChoice---
输出一个二维数组b[m][n]中所有元素值的时间复杂度为（）。
A.O(n) B.O(m+n) C.O(n^3) D.O(mn)---
D
===
ff282571-28c9-4527-8a09-7f779004c868---
33---
SingleChoice---
一个算法的时间复杂度为(3n^3+2nlog2 n+4n-7)/(5n)，其时间复杂度为（）。
A.O(n) B.O(nlog2 n) C.O(n^3) D.O(log2 n)---
A
===
d6114101-665f-481b-b932-a8e321111ef5---
34---
SingleChoice---
某算法的时间代价为T(n)=100n+10nlog2 n+n^2+10，其时间复杂度为（）。
A.O(n) B.O(n^2) C.O(n^3) D.O(1)---
C
===
f17298b8-ed19-4bee-bdf3-015bd5563945---
36---
SingleChoice---
若需要利用形参直接访问实参，则应把形参变量说明为（）参数。
A.指针型 B.引用型 C.传值型 D.常值型---
B
===
1fd276f6-b856-4e0d-81ff-a8840fd5d165---
37---
SingleChoice---
当一个作为实参传递的变量占用的存储空间较大并可能被修改时，最好把对应的形参说明为（），以节省参数值的传输时间和存储参数的空间。
A.基本类型 B.引用型 C.指针型 D.常值引用型---
B
===
b33295e5-13b2-4dd3-9d1f-3ff55e1e8a98---
38---
SingleChoice---
当需要用一个形参直接改变对应实参的值时，该形参应说明为（）。
A.基本类型 B.引用型 C.指针型 D.常值引用型---
B
===
d2c65eed-5c50-42e2-9840-0442f6d8fc14---
11---
TrueFalse---
算法中语句执行的频度就是算法的时间复杂度。---
F
===
87379c74-1a70-4412-9541-b50a5db19240---
12---
TrueFalse---
一个算法的语句频度之和为1024n+4nlog2 n,则该算法的时间复杂度为O(nlog2 n)。---
T
===
995ce007-2d0e-4e22-9735-6984e29cb5f7---
13---
TrueFalse---
在很多情况下，数据元素的取值情况不同，算法的执行时间也不同。---
T
===
889340b3-b9be-4be2-8e45-b8c1433d932e---
14---
TrueFalse---
在很多情况下，数据元素的排列情况不同，算法执行所需时间也不同。---
T
===
ff8aa0ad-dbd7-42a3-99d3-c2ce8462791a---
15---
TrueFalse---
在很多情况下，数据元素的查找概率不同，算法的查找时间也不同。---
T
===
79acd392-c918-4e5c-ab83-f0705d734f9f---
16---
TrueFalse---
算法的时间效率和空间效率往往相互冲突，有时很难两全其美。---
T
===
cbc7f90d-5c98-420e-8429-e8ec374b29be---
1---
Programming---
题目名称：黑与白

问题描述：有A、B、C、D、E这5个人，每个人额头上都贴了一张黑或白的纸。5人对坐，每个人都可以看到其他人额头上纸的颜色。
A说：“我看见有3人额头上贴的是白纸，1人额头上贴的是黑纸。”
B说：“我看见其他4人额头上贴的都是黑纸。”
C说：“我看见1人额头上贴的是白纸，其他3人额头上贴的是黑纸。”
D说：“我看见4人额头上贴的都是白纸。”
E什么也没说。
现在已知额头上贴黑纸的人说的都是谎话，额头上贴白纸的人说的都是实话。问这5人谁的额头上贴的是白纸，谁的额头上贴的是黑纸？---
源程序：
if __name__=="__main__":
    #A、B、C、D、E五个人，每个人额头上都帖了一张黑或白的纸
    #变量a、b、c、d、e分别代表A、B、C、D、E五个人额头上贴纸的颜色，
    # 当变量的取值为1时表示该人额头上贴纸为白色，当变量取值为0时表示该人额头上贴纸为黑色
    for a in range(2):  #a,b,c,d,e变量值要么为0，要么为1，0为黑色，1为白色
        for b in range(2):
            for c in range(2):
                for d in range(2):
                    for e in range(2):
                        if (a and (b+c+d+e == 3) or ((not a) and (b+c+d+e != 3))):   #A
                            if(b and (a+c+d+e == 0) or ((not b) and (a+c+d+e != 0))):  #B
                                if(c and (a+b+d+e == 1) or ((not c) and (a+b+d+e != 1))): #C
                                    if (d and (a+b+c+e == 4) or ((not d) and (a+b+c+e != 4))): #D
                                        a1 = "白" if a==1 else "黑"    #三元表达式
                                        b1 = "白" if b==1 else "黑"
                                        c1 = "白" if c==1 else "黑"
                                        d1 = "白" if d==1 else "黑"
                                        e1 = "白" if e==1 else "黑"
                                        print("A额头上的贴纸是" + a1 + "色的.")
                                        print("B额头上的贴纸是" + b1 + "色的.")
                                        print("C额头上的贴纸是" + c1 + "色的.")
                                        print("D额头上的贴纸是" + d1 + "色的.")
                                        print("E额头上的贴纸是" + e1 + "色的.")
===
f18b3856-357f-448c-8113-5b3cc423da07---
2---
Programming---
题目名称：委派任务

问题描述：某项任务需要在A、B、C、D、E、F这6个人中挑选人来完成，但挑选人受限于以下条件：
1）A和B两个人至少去一人。
2）A和D不能同时去。
3）A、E和F三人中要挑选两个人去。
4）B和C同时去或者都不去。
5）C和D两人中只能去一个。
6）如果D不去，那么E也不去。
试编程求出应该让哪几个人去完成这项任务。---
源程序：
if __name__ == "__main__":
    # A、B、C、D、E、F 可能取值分别 0 或 1,  (0: 不去, 1: 去)
    # 穷举所有情况
    for A in range(2):
        for B in range(2):
            for C in range(2):
                for D in range(2):
                    for E in range(2):
                        for F in range(2):
                            # 逻辑表达式作为判断条件
                            if (A+B >= 1) and (A+D != 2) and (A+E+F == 2) and ((B+C==0) or (B+C==2)) and (C+D==1) and ((D+E==0) or D==1):
                                a = '' if A == 1 else "未"  # 三元表达式
                                print("A" + a + "被选择去完成任务。")

                                b = '' if B == 1 else "未"
                                print("B" + b + "被选择去完成任务。")

                                c = '' if C == 1 else "未"
                                print("C" + c + "被选择去完成任务。")

                                d = '' if D == 1 else "未"
                                print("D" + d + "被选择去完成任务。")

                                e = '' if E == 1 else "未"
                                print("E" + e + "被选择去完成任务。")

                                f = '' if F == 1 else "未"
                                print("F" + f + "被选择去完成任务。")
===
9c6cbb75-5916-4c6a-b0ea-0c2c59535568---
3---
Programming---
题目名称：旅客国籍

问题描述：在一个旅馆中住着6个不同国籍的人，他们分别来自美国、德国、英国、法国、俄罗斯和意大利。他们的名字分别叫A、B、C、D、E和F，要说明的是名字的顺序与前面提到的国籍不一定是相互对应的。现在已知：
1）A和美国人是医生。
2）E和俄罗斯人是教师。
3）C和德国人是技师。
4）B和F曾经当过兵，而德国人从未参过军。
5）法国人比A年龄大，意大利人比C年龄大。
6）B同美国人下周要去西安旅行，而C同法国人下周要去杭州度假。
现要求根据上述已知条件，编程求出A、B、C、D、E和F各是哪国人。---
源程序：
country = [" ", "美国", "英国", "法国", "德国", "意大利", "俄罗斯"]   #国名

def Nationality():
    #初始化条件矩阵
    a = []
    for i in range(7):
        b = []
        for j in range(7):
            b.append(j)
        a.append(b)

    for i in range(1, 7):   #条件矩阵每一列的第0号元素作为该列数据处理的标记
        a[0][i] = 1         #标记该列尚未处理

    a[1][1] = a[2][1] = a[3][1] = a[5][1] = 0  #输入条件矩阵中的各种条件
    a[1][3] = a[2][3] = a[3][3] = 0     #0表示不是该国人
    a[1][4] = a[2][4] = a[3][4] = a[5][4] = a[6][4] = 0
    a[3][5] = 0
    a[1][6] = a[3][6] = a[5][6] = 0

    x = 0
    y = 0
    while a[0][1] + a[0][2] + a[0][3] + a[0][4] + a[0][5] + a[0][6] > 0:
        #当所有六列均处理完毕后退出循环
        for i in range(1, 7):  #i为列坐标
            if a[0][i] != 0:   #若该列尚未处理，则进行处理
                e = 0
                for j in range(1, 7):  #j变量保存行坐标，e变量是该列中非0元素计数器
                    if a[j][i] != 0:
                        #统计每列中的非0元素个数
                        x = j   #x变量保存行坐标
                        y = i   #y变量保存列坐标
                        e += 1
                if e == 1:       #若该列只有一个元素为非零，则进行消去操作
                    for t in range(1, 7):
                        if t != i:
                            a[x][t] = 0   #将非零元素所在的行的其他元素置0
                    a[0][y] = 0      #设置该列已处理完毕的标记

    print("矩阵最终状态为：")
    #输出执行消去操作后矩阵的最终状态
    for i in range(7):
        print(a[i])

    print("推断结果为：")
    for i in range(1, 7):
        print(chr(ord('A') - 1 + i), '来自: ', end='')
        for j in range(1, 7):
            if a[i][j] != 0:
                print(country[a[i][j]], '。')
                break


if __name__ == '__main__':
    Nationality()
===
17a7df38-69b4-4630-9786-e5f5e33d7734---
4---
Programming---
题目名称：谁是窃贼

问题描述：警察审问4名窃贼嫌疑犯。现在已知，这4人当中仅有一名是窃贼，还知道这4个人中的每个人要么是诚实的，要么总是说谎。下面是这4个人给警察的回答。
·甲说：“乙没有偷，是丁偷的。”
·乙说：“我没有偷，是丙偷的。”
·丙说：“甲没有偷，是乙偷的。”
·丁说：“我没有偷。”
请根据这4个人的回答判断谁是窃贼。---
源程序：
if __name__ == "__main__":
    #甲乙丙丁分别用A，B，C，D代表。A，B，C，D的值要么为 1，要么为 0.
    # 为 1 表示是窃贼， 为 0 表示不是
    # 满足四个条件： B+D=1, B+C=1, A+B=1, A+B+C+D=1
    A, B, C, D = 1, 0, 0, 0
    for i in range(1, 4+1):  #i=1,2,3,4
        if B+D == 1 and B+C == 1 and A+B == 1:
            break
        else:
            if i == 1:
                A=0
                B=1
            if i == 2:
                B=0
                C=1
            if i == 3:
                C=0
                D=1
    print("判断结果：")
    if i == 1:
        print("甲是窃贼\n")
    if i == 2:
        print("乙是窃贼\n")
    if i == 3:
        print("丙是窃贼\n")
    if i == 4:
        print("丁是窃贼\n")
===
e0af2168-b9c9-45e7-b12a-827e7777e478---
5---
Programming---
题目名称：谁在说谎

问题描述：现有张三、李四和王五三个人，张三说李四在说谎，李四说王五在说谎，而王五说张三和李四两人都在说谎。要求编程求出这三个人中到底谁说的是真话，谁说的是假话。---
源程序：
if __name__ == "__main__":
    # x、y和z分别表示张三、李四和王五三人说话真假的情况
    # 当x、y或z的值为1时表示该人说的是真话，值为0时表示该人说的是假话
    #使用三重循环穷举所有情况、
    for x in range(2):
        for y in range(2):
            for z in range(2):
                if (x and (not y) or (not x) and y) and (y and (not z) or (not y) and z) and (z and x ==0 and y==0 or (not z) and x+y != 0):
                    a = '真' if x == 1 else '假'
                    b = '真' if y == 1 else '假'
                    c = '真' if z == 1 else '假'
                    print("张三说的是" + a + "话")
                    print("李四说的是" + b + "话")
                    print("王五说的是" + c + "话")
